# 执行上下文

## 声明提升

通过 var 声明的变量，在定义语句之前就可以访问到，值为 undefined。

```js
console.log(a) // undefined
var a = 100
```

通过 function 声明的函数，在之前就可以直接调用。

```js
foo() // 100
function foo() {
  console.log(100)
}
```

**注意：函数在 JavaScript 中是一等公民，先执行函数提升，再执行变量提升，函数在变量前面。**

## 执行上下文

代码分类（位置）：全局代码和函数（局部）代码。

执行上下文对象，包含对应作用域中的所有变量属性。

### 全局执行上下文

在执行全局代码前将 window 确定为全局执行上下文。

对全局数据进行预处理：

- var 定义的全局变量 --> undefined，添加为 window 的属性。

- function 声明的全局函数 --> 赋值（fun），添加为 window 的方法。

- this --> 赋值（window）。

- 开始执行全局代码。

生命周期：准备执行全局代码前产生，当页面刷新、关闭页面时死亡。

### 函数执行上下文

在调用函数，准备执行函数体之前，创建对应的函数执行上下文对象（虚拟的，存在于栈中）。

对局部数据进行预处理：

- 形参变量 --> 赋值（实参），添加为执行上下文的属性。

- arguments --> 赋值（实参列表），添加为执行上下文的属性。

- var 定义的局部变量 --> undefined，添加为执行上下文的属性。

- function 声明的函数 --> 赋值（fun），添加为执行上下文的方法。

- this --> 赋值（调用函数的对象）。

- 开始执行函数体代码。

生命周期：调用函数时产生，函数执行完时死亡。

## 执行上下文栈

执行上下文栈是用来管理产生的多个执行上下文。

1. 在全局代码执行前，JavaScript 引擎就会创建一个栈来存储管理所有的执行上下文对象。

2. 在全局执行上下文（window）确定后，将其添加到栈中（压栈）。

3. 在函数执行上下文创建后，将其添加到栈中（压栈）。

4. 在当前函数执行完毕后，将栈顶的对象移除（出栈）。

5. 当所有的代码执行完后，栈中只剩下 window。

```js
// 1. 进入全局执行上下文
var a = 10
var bar = function(x) {
  var b = 5
  foo(x + b) // 3. 进入 foo 函数执行上下文
}
var foo = function(y) {
  var c = 5
  console.log(a + c + y)
}
bar(10) // 2. 进入 bar 函数执行上下文
```

面试题：

```js
console.log('gb: ' + i)
var i = 1
foo(i)
function foo(i) {
  if(i === 4) return
  console.log('fb: ' + i)
  foo(i + 1) // 递归调用：在函数内部调用自己
  console.log('fe: ' + i)
}
console.log('ge: ' + i)
```

上图依次输出什么？

```js
// gb: undefined
// fb: 1
// fb: 2
// fb: 3
// fe: 3
// fe: 2
// fe: 1
// ge: 1
```

整个过程产生了几个执行上下文？

一个全局执行上下文（window），四个函数执行上下文（foo(1)，foo(2)，foo(3)，foo(4)）。

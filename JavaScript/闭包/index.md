# 闭包

闭包的产生：当一个嵌套的内部（子）函数引用了嵌套的外部（父）函数的（变量 / 函数）时，就产生了闭包。

**执行函数定义就会产生闭包（不用调用内部函数）。**

闭包到底是什么？

- 理解一：闭包是嵌套的内部函数（绝大部分）。

- 理解二：包含被引用（变量 / 函数）的对象（极少数人）。

注意：闭包存在于嵌套的内部函数中。

通过 chrome 调试工具中的 `closure` 选项可以查看闭包。

产生闭包的条件：

- 函数嵌套。

- 内部函数引用了外部函数的数据（变量或者函数）。

常见的闭包：

- 将函数作为另一个函数返回值。

- 将函数作为实参传递给另一个函数调用。

## 闭包的作用

1. 使用函数内部的变量在函数执行完后，仍然存活在内存中（延长了局部变量的生命周期）。

2. 让函数外部可以操作（读 / 写）到函数内部的数据（变量 / 函数）。

问题一：

函数执行完后，函数内部声明的局部变量是否还存在？

一般是不存在，存在于闭包中的变量才可能存在。

问题二：

在函数外部能直接访问函数内部的局部变量吗？

不能，但我们可以通过闭包让外部操作它。

## 闭包的生命周期

- 产生：在嵌套内部函数定义执行完时就产生了（不是在调用时）。

- 死亡：在嵌套的内部函数成为垃圾对象时。

```js
function foo() {
  // 此时闭包就已经产生了（函数提升，内部函数对象已经创建了）
  var a = 1
  return function() {
    console.log(++a)
  }
}
var fn = foo()
fn() // 2
fn() // 3
f = null // 闭包死亡（包含闭包的函数对象引用断开，成为垃圾对象）
```

## 闭包应用（自定义js模块）

js 模块：具有特定功能的 js 文件。

将所有的数据和功能都封装在一个函数内部（私有的）。

只向外暴露一个包含 n 个方法的对象或函数。

模板的使用者，只需要通过模块暴露的对象调用方法来实现对应的功能。

```js
(function(window) {
  // 私有数据
  var count = 0
  window.utils = {
    getCount() {
      console.log(++count) 
    }
  }
})(window)
utils.getCount() // 1
utils.getCount() // 2
```

# 数组

数组也是一个对象。它和我们普通对象功能相似，也是用来存储一些值的。

不同的是普通对象是使用字符串作为属性名的，而数组是使用数字来作为索引（从 0 开始的整数就是索引）操作数组元素的。

数组的存储性能比普通对象要好，在开发中我们经常使用数组来存储一些数据。

使用 `typeof` 检查一个数组时，会返回 `'object'`。

```js
typeof [] // object
```

## 创建数组

使用字面量来创建数组，可以在创建时就指定数组中的元素。

```js
const arr = [1, 2, 3, 4, 5, 6]
```

使用构造函数创建数组时，也可以同时添加元素，将要添加的元素作为构造函数的参数传递，元素之间使用逗号隔开。

```js
const arr = new Array(1, 2, 3, 4, 5, 6)
```

如果只传一个整数，则会创建一个长度为整数的数组。

```js
const arr = new Array(100) // (100) [empty × 100]
```

数组中的元素可以是任意的数据类型。

```js
[[1, 2, 3], [4, 5, 6]] // 这种叫二维数组
```

## 操作数组

向数组中添加元素。

```js
const arr = []

arr[0] = 1
arr[1] = 2
arr[2] = 3 // arr [1, 2, 3]
```

读取数组中的元素。

如果读取不存在的索引，它不会报错而是返回 `undefined`。

```js
const arr = [1, 2, 3]

arr[0] // 1
arr[1] // 2
arr[2] // 3
arr[3] // undefined
```

获取数组长度。

可以使用 `length` 属性来获取数组的长度。

对于连续的数组，使用 `length` 可以获取到数组的长度（元素的个数）。

```js
const arr = [1, 2, 3, 4, 5, 6]
arr.length // 6
```

对于非连续的数组，使用 `length` 会获取到数组的最大索引 + 1。

```js
const arr = []
arr[100] = 1
arr.length // 101
```

尽量不要创建非连续的数组。

`length` 是一个可以读写的属性。

如果修改的 `length` 大于原长度，则多出部分会空出来。

```js
const arr = [1]

arr.length = 100

arr // (100) [1, empty × 99]
```

如果修改的 `length` 小于原长度，则多出的元素会被删除。

```js
const arr = [1, 2, 3, 4, 5, 6]

arr.length = 1

arr // [1]
```

## 数组的常用方法

`push()`

该方法可以向数组的末尾添加一个或多个元素，并返回数组新的长度。

```js
const arr = []

arr.push(1) // 1
arr.push(2, 3, 4) // 4

arr // [1, 2, 3, 4]
```

`pop()`

该方法可以删除数组的最后一个元素，并将删除的元素作为返回值返回。

```js
const arr = [1, 2, 3]

arr.pop() // 3

arr // [1, 2]
```

`unshift()`

向数组开头添加一个或多个元素，并返回新的数组长度。

向前边插入元素以后，其他的元素索引会依次调整。

```js
const arr = [1, 2, 3]

arr.unshift(4) // 4
arr.unshift(5, 6) // 6

arr // [5, 6, 4, 1, 2, 3]
```

`shift()`

可以删除数组的第一个元素，并将被删除的元素作为返回值返回。

```js
const arr = [1, 2, 3, 4, 5, 6]

arr.shift() // 1

arr // [2, 3, 4, 5, 6]
```

`forEach`

该方法需要一个函数作为参数。

像这种函数，由我们创建但不由我们调用，我们称为回调函数。

数组中有几个元素，函数就会执行几次，每次执行时，浏览器会将遍历到的元素以实参的形式传递进去，我们可以来定义形参，来读取这些内容。

```js
const arr = [1, 2, 3]

arr.forach(function(item, index, array) {
  // item 当前正在遍历的元素
  // index 当前正在遍历元素的索引
  // array 正在遍历的数组
})
```

`slice()`

用来从数组中提取指定元素。

该方法不会改变元素数组，而是将截取到的元素封装到一个新数组中返回。

该方法接收两个参数。

- 参数 1：截取开始的位置索引，包含开始索引。

- 参数 2：截取结束的位置索引，不包含结束索引。

```js
const arr = [1, 2, 3, 4, 5, 6]

arr.slice(1, 3) // [2, 3]
```

第二个参数可以省略不写，此时会截取从开始索引往后的所有元素。

```js
arr.slice(3) // [4, 5, 6]
```

参数也可以是一个负值，将数组长度与负值相加，得到一个正确的索引。

```js
const arr = [1, 2, 3, 4, 5, 6] // 数组长度为 6

arr.slice(-2) // 6 + -2 = 4 arr.slice(4) => [5, 6]
arr.slice(-2, -1) // arr.slice(4, 5) => [5]
```

`splice()`

可以用来删除数组中指定的元素或者在指定位置添加元素。

使用 `splice()` 会影响到数组，会将指定元素从原数组中删除。

并将删除的元素封装在一个新的数组中返回。

该方法接收多个参数。

- 参数 1：表示开始位置的索引。

- 参数 2：表示删除的数量。

- 参数 3 及以后可以传递一些新的元素，这些元素将会自动插入到开始位置索引前边。

```js
const arr = [1, 2, 3, 4, 5, 6]

arr.splice(1, 2) // [2, 3] 删除了 2 3 元素

arr // [1, 4, 5, 6]

arr.splice(1, 0, 2, 3) // [] 在索引 1 的位置删除 0 个元素，并在前面添加 2 3 元素

arr // [1, 2, 3, 4, 5, 6]
```

`concat()`

合并多个数组，并将新的数组返回。

该方法不会对原数组产生影响。

```js
const arr = [1, 2, 3]

arr.concat([4], [5], [6, 7]) // [1, 2, 3, 4, 5, 6, 7]

arr // [1, 2, 3]
```

`join()`

该方法可以将数组转换为一个字符串。

该方法不会对原数组产生影响，而是将转换后的字符串作为结果返回。

在 `join()` 中可以指定一个字符串作为参数，这个字符串将会成为数组中元素的连接符，如果不指定，则默认以逗号为连接符。

```js
const arr = [1, 2, 3, 4, 5, 6]

arr.join() // '1,2,3,4,5,6'
arr.join('@') // '1@2@3@4@5@6'
```

`reverse()`

该方法用来反转数组，会直接改变原数组。

```js
const arr = [1, 2, 3, 4, 5, 6]

arr.reverse() // [6, 5, 4, 3, 2, 1]
```

`sort()`

可以用来对数组中的元素进行排序。

也会影响原数组，默认会按照 `Unicode编码` 进行排序。

即使是纯数字，使用 `sort()` 排序时，也会按照 `Unicode编码` 来排序。

```js
const arr = [2, 10, 3]

arr.sort() // [10, 2, 3]
```

我们可以在 `sort()` 添加一个回调函数，来指定排序规则。

```js
const arr = [1, 2, 3]

arr.sort(function(firstEl, secondEl) {
  console.log(firstEl, secondEl)
})
// 2 1
// 3 2
```

浏览器会根据回调函数的返回值决定元素的顺序。

- 如果返回值小于 0，则元素会交换位置。

- 如果元素大于等于 0，则元素位置不变。

```js
const arr = ['q', 'w', 'e']

arr.sort(_ => 1) // ['q', 'w', 'e']
arr.sort(_ => 0) // ['q', 'w', 'e']
arr.sort(_ => -1) // ["e", "w", "q"]
```

如果需要升序排列，则返回 `firstEl - secondEl`。

如果需要降序排列，则返回 `secondEl - firstEl`。

```js
const arr = [2, 10, 3]

arr.sort((firstEl, secondEl) => firstEl - secondEl) // [2, 3, 10]
arr.sort((firstEl, secondEl) => secondEl - firstEl) // [10, 3, 2]
```
